import sys
sys.path.append('/etc/kubernetes/venv/lib/python3.9/site-packages/gymnasium/envs') 
import dash
from dash import dcc, html
from dash.dependencies import Input, Output
import plotly.graph_objects as go
import random
import time
import subprocess
import threading
from multiprocessing import Process

from classic_control.scheduling import getReward


def startGraph():

    app = dash.Dash(__name__)
    app.layout = html.Div([
        dcc.Graph(id='dynamic-graph'),
        dcc.Interval(
            id='interval-component',
            interval=1000, 
            n_intervals=0
        )
    ])

    #empty graph
    initial_figure = go.Figure()
    initial_figure.add_trace(go.Scatter(x=[], y=[], mode='markers', marker=dict(size=10)))

    #layout
    initial_figure.update_layout(title='Reward function', xaxis_title='#Action', yaxis_title='Reward')

    x_data = []
    y_data = []


    @app.callback(
        Output('dynamic-graph', 'figure'),
        [Input('interval-component', 'n_intervals')]
    )
    def update_graph(n_intervals):
        nonlocal x_data, y_data

        #update point
        new_x = random.uniform(0, 10)
        new_y = random.uniform(0, 10)

        # Aggiorna i dati
        x_data.append(new_x)
        y_data.append(new_y)

        # Aggiorna il grafico con i nuovi dati
        updated_figure = go.Figure(initial_figure)
        updated_figure.update_traces(x=x_data, y=y_data)

        return updated_figure

    # Esegui l'app Dash
    app.run_server(debug=True, host='0.0.0.0', port=8050)
""" 
    subprocess.Popen(["kubectl", "port-forward", f"kube-scheduler-vbeta3-control-plane", "8083:8050", "-n", "kube-system"])
    time.sleep(5)
 """

if __name__ == "__main__":
    startGraph()
