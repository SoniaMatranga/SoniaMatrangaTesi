import sys
sys.path.append('/etc/kubernetes') 
from typing import Optional, Union
import numpy as np
import gymnasium as gym
from gymnasium import spaces
from model.main import node_count, get_worker_nodes_internal_ips, get_nodes_state
import time
import socket
import json

def setSuggestion(agent_suggestions):
    try:
        client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        client_socket.connect(("localhost", 8765))
        command = "setSuggestion"
        value = json.dumps(agent_suggestions)
        request = f"{command} {value}"
        client_socket.send(request.encode("utf-8"))
        client_socket.close()
    except socket.error as e:
        print(f"Something went wrong in setting suggestion... \n{e}")
        sys.exit()

def getStep():
    try:
        client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        client_socket.connect(("localhost", 8765))
        command = "getStep"
        request = f"{command}"
        client_socket.send(request.encode("utf-8"))
        step_value = client_socket.recv(1024).decode("utf-8")
        client_socket.close()
        return step_value.strip()
    except socket.error as e:
        print(f"Something went wrong in getting step... \n{e}")
        sys.exit()

def setStep(step_value):
    try:
        client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        client_socket.connect(("localhost", 8765))
        command = "setStep"
        value = json.dumps(step_value)
        request = f"{command} {value}"
        client_socket.send(request.encode("utf-8"))
        client_socket.close()
    except socket.error as e:
        print(f"Something went wrong in setting step... \n{e}")
        sys.exit()
  

class SchedulingEnv(gym.Env[np.ndarray, Union[int, np.ndarray]]):

    metadata = {
        "render_modes": ["human", "rgb_array"],
        "render_fps": 50,
    }


    def __init__(self, render_mode: Optional[str] = None):

        self.worker_ips = get_worker_nodes_internal_ips()
        self.num_of_nodes = None
        self.min_usage = np.zeros(node_count()-1, dtype=np.float32)
        self.max_usage = np.full(node_count()-1, float('inf'), dtype=np.float32)
        self.num_of_actions = None
        self.action_space = spaces.Discrete(node_count()+ 1)
        self.observation_space = spaces.Box(self.min_usage, self.max_usage,  dtype=np.float32) #values of resource usage in range [min_usage, max_usage]    
        self.usage_treshold = 1
        self.steps_beyond_terminated = None
        self.screen = None
        self.policy="LA" #set MA, LA or LC policy
        self.resource= "CPU" #set CPU, MEM, NET or DISK resource (not used is LC policy)
        self.reset()



    def reset(
        self,
        *,
        seed: Optional[int] = None,
        options: Optional[dict] = None,
    ):
        super().reset(seed=seed)
        self.state = get_nodes_state(self.policy, self.resource, self.worker_ips)
        self.num_of_nodes = node_count()
        self.num_of_actions = node_count() + 1
        return np.array(self.state, dtype=np.float32), {}
    




    def step(self, action):
        assert self.action_space.contains(
            action
        ), f"{action!r} ({type(action)}) invalid"
        assert self.state is not None, "Call reset before using step method."

        
        while getStep()!= "true":
            print(f"Waiting for suggestion request...")
            time.sleep(1) 
           
        print(f"ACTION: {action}")

        # state update 
        self.state = get_nodes_state(self.policy, self.resource, self.worker_ips)
        node_to_select = -1  # Start from no node to select

        ########################   MOST ALLOCATED POLICY  ############################
        ##############################################################################

        if self.policy == "MA":
            #evaluate action 
            max_resource_usage = float(0)     

            for i, usage in enumerate(self.state):  #find node that has highest resource utilization
                resource_usage = usage
                if resource_usage > max_resource_usage:
                    max_resource_usage = resource_usage
                    node_to_select = i

            if node_to_select != -1:        
                print(f"action: {action}   node_to_select: {node_to_select +1}")
                terminated = action.__eq__(node_to_select + 1)  
            else:
                print("No node suggested. Suggest don't schedule.")

            # REWARD   
            unused_nodes = sum(1 for value in self.state if value < 6)
            reward = int((unused_nodes/(self.num_of_nodes -1))*10 if terminated else 0)  
            print(f"TERMINATED: {terminated}")
            print(f"REWARD: {reward}")

        ########################   LEAST ALLOCATED  POLICY  ############################
        ################################################################################
            
        elif self.policy == "LA":
            # evaluate action 
            min_resource_usage = float('inf')     

            for i, usage in enumerate(self.state):  #find node that has lower resource utilization
                resource_usage = usage
                if resource_usage < min_resource_usage:
                    min_resource_usage = resource_usage
                    node_to_select = i

            if node_to_select != -1:
                print(f"action: {action}   node_to_select: {node_to_select +1}")
                terminated = action.__eq__(node_to_select + 1)
                
            else:
                print("No node suggested. Suggest don't schedule.")

            # REWARD
            reward = 1 if terminated else 0  # Binary sparse rewards
            print(f"TERMINATED: {terminated}")
            print(f"REWARD: {reward}")

        ########################   LEAST CONNECTIONS  POLICY  ############################
        ##################################################################################
            
        elif self.policy == "LC":
            # evaluate action 
            min_connections = float('inf') 
            max_connections = float('-inf')    

            for i, connections in enumerate(self.state):  #find node that has fewest active connections
                active_connections = connections 
                if active_connections <  min_connections:
                    min_connections = active_connections
                    node_to_select = i
                if active_connections > max_connections:
                    max_connections = active_connections

            if node_to_select != -1:
                print(f"action: {action}   node_to_select: {node_to_select +1}")
                terminated = action.__eq__(node_to_select + 1)
                
            else:
                print("No node suggested. Suggest don't schedule.")

            # REWARD
            reward = int((1 -(min_connections/max_connections)))*10 if terminated else 0 
            print(f"TERMINATED: {terminated}")
            print(f"REWARD: {reward}")

        ####################### FINAL SUGGESTION #########################

        agent_suggestions = {}
        node_names= self.worker_ips
        for i, node_name in enumerate(node_names):
            if i == (action - 1):
                agent_suggestions[node_name] = 10
            else:
                agent_suggestions[node_name] = 1
        print(f"agent_suggestions: {agent_suggestions}")
        setSuggestion(agent_suggestions)
        setStep(False)
        
        return np.array(self.state, dtype=np.float32), reward, terminated, False, {}

    

    def close(self):
        if self.screen is not None:
            import pygame
            pygame.display.quit()
            pygame.quit()
            self.isopen = False

            
